# Hooks

## useState

State Hooks 是一个在函数组件中使用的函数（useState）用于在函数组件中使用状态

useState 有一个参数，这个参数表示状态的默认值

返回一个数组
- 第一项：状态的值
- 第二项：改变状态值的函数

第N次调用useState
检查该节点的状态数组是否存在下标N
不存在
  1. 使用默认值创建一个状态
  2. 将该状态加入到状态数组中下标为N
存在
  1. 忽略掉默认值
  2. 直接得到状态值

useState 最好写在起始位置
useState 严禁出现在代码块中（判断、循环等）
useState 返回的函数，引用不变（节约内存空间）
使用函数改变数据，若数据和之前数据完全相等（使用Object.is比较），则不会重新渲染，达到优化效率
使用函数改变数据，传入的值不会和原来的数据合并，是直接替换
强制刷新
  - 类组件：this.forceUpdate()  不会运行shouldComponentUpdate
  - 函数组件：
    `const [, forceUpdate] = useState({})`
    `forceUpdate({})`

函数组件中改变状态可能是**异步的**(在dom事件中)，多个状态变化会合并以提升效率，应该使用回调函数的方式改变状态

## useEffect

Effect Hook 在函数组件中处理副作用

副作用：
1. ajax请求
2. 计时器
3. 其他异步操作
4. 更改真实DOM
5. 本地存储
6. 其他会对外部产生影响的操作等

useEffect 
- 第一个参数
  - 接受一个函数（副作用函数）作为参数，接受的函数就是用于副作用操作的函数
- 返回值[可选]：返回值是一个函数（清理函数）
  - 首次加载不会运行清理函数
  - 重新加载后会先运行清理函数，在渲染之后运行
  - 组件被销毁时一定会运行
- 第二个参数
  - 一个数组，记录副作用函数的依赖项
  - 当组件重新渲染后，只有依赖数据与上次不一样，才会执行副作用

- tip
1. 副作用函数执行，是在页面完成正式UI渲染后，用户看到效果后，是异步的，不会阻塞浏览器
  - 与类组件中 componentDidMount和componentDidUpdate不同
    类组件两个生命周期函数 是在更改了真实DOM，但是用户还没看到UI更新，是同步的
    useEffect是在修改了真实DOM，用户已经看到UI更新，是异步的

2. 每个函数组件中可以多次使用useEffect

3. 副作用函数中，如果使用了函数上下文中的变量，由于闭包的影响，会导致副作用函数中变量不会实时变化

4. 每次渲染后，新的副作用函数会覆盖之前的副作用函数，尽量保持副作用函数稳定（每次传入的函数保持同一个）

## 自定义hook

把常用的、跨越多个组件的hook功能，抽离成一个函数，该函数即为自定义hook
- 自定义hook 要按照hook规则实现
  - 以useXXX开头
  - 调用自定义hook时要放在函数顶层（不放在代码块内）

例如：很多组件都要在第一次加载完成后 发送请求获取XX数据

## useReducer

- 关于reducer

  Redux 最初来自 Flux: facebook出品的一个数据流仓库
  1. 规定了数据单向流动
  2. 数据存储在数据仓库
  3. action是改变数据的唯一原因

- useReducer

  第一个参数，reducer函数
  第二个参数，初始值
  第三个参数，一个回调函数，该函数的返回值会作为初始值，该回调函数有一个参数，参数就是第二个参数的值，一般用于第二个参数需要复杂计算才能得到初始值的情况使用，比如第二个参数来自props，需要计算后才能的到初始值

## useContext

获取上下文数据

## useCallback

函数的地址每次重新渲染都会发生变化，导致子组件跟着重新渲染，若子组件是PureComponent，就会失效

该函数有两个参数
- 第一个参数：
  - 函数。useCallback会固定该函数的引用，只要依赖项没发生变化，则始终返回固定的函数引用
- 第二个参数
  - 依赖项

## useMemo

保持一些比较稳定的数据，通常用于性能优化

## useRef

能产生一个具有唯一地址的对象