# 函数

函数实际上时对象，每个函数都是`Function`类型的实例

## 函数声明与函数表达式

函数声明提升: 函数声明会在任何代码执行之前先被读取并添加到执行陕西该文

函数声明（字面量）: 有函数提升
`function func1() {}`
函数表达式: 无函数提升（用var定义的话，func2变量会被提升到顶部并且赋值为undefined）
`let func2 = function() {}`

## this指向

全局作用域中 `this`指向全局对象(如window)
  
函数作用域中，取决于 **函数如何被调用**

  1. 函数直接调用，`this`指向全局对象(如window)

  2. 通过对象调用 `obj.func()` ，`this` 指向该对象，（将对象方法保存到全局变量调用则指向全局对象 `var a = obj.func; a()`）

- `call`、`apply`、`bind`

  `Function`的原型上提供了三个修改this指向的方法

  - `call`：第一个参数this指向, 后续参数依次传入 `func.call(this, ...args)`
  
  - `apply`：第一个参数this指向，后续参数放在数组内传入 `func.apply(this, [...args])`

  - `bind`: 绑定this指向，返回一个函数 `func.bind(this, ...args)` 后续参数也可以当做先固定的参数

## 箭头函数

箭头函数中的this指向,取决于箭头函数**定义**时的this指向

箭头函数**没有原型**，不能当作构造函数

若箭头函数只有一条 `return` 语句时可以省略大括号{}和 `return` 关键字，会隐式返回这行代码的值

箭头函数如果只有一个参数可以不用括号，多个或者无参数才需要使用括号

箭头函数没有call apply bind 但是可以调用，用了和没用一样，但是不报错

## new

可以通过 `new.target` 属性是否是通过 `new` 关键字调用的

```js
  function Func() {
    if (new.target) {
      console.log('Func 通过 new 关键字 实例化')
    } else {
      console.log('Func 未通过 new 关键字')
    }
  }

  new Func(); // Func 通过 new 关键字 实例化
  Func();     // Func 未通过 new 关键字
```

## 原型与原型链

### 原型

构造函数带有一个`prototype`属性（函数原型）函数原型可以看作是一个对象，里面包含了正常对象可以包含的属性和方法。

- `constructor`：构造函数原型内的prototype属性指向该构造函数本身

  ```js
    function Foo() { 
      //...
    }
    Foo.prototype.constructor === Foo // ture
  ```

### 隐式原型

- `__protp__`: 对象有一个私有属性 `__proto__`,该属性指向它构造函数的原型

  ```js
    const foo = new Foo()
    foo.__proto__ === Foo.prototype // true
  ```

- 构造函数的`__proto__`指向`Function.prototype` (绝大多数函数都是通过`new Function()` 创建的，即是`Function`的实例对象)

### 原型链

- 基于原型链的继承

当访问一个对象的属性时：

1. 查看该对象上是否存在目标属性，若存在则返回该属性
2. 查看该对象的隐式原型上是否存在目标属性，若存在则返回该属性
3. 继续往上层隐式原型中查找，直到搜索到该属性或到达原型链的顶端（`Object的原型的隐式原型为null`）

![原型链](/原型链.png)

[习题-原型链模拟继承](/面试/JS.md#原型链继承)

## 执行上下文

### 执行上下文 EC

当控制器运行到一段可执行的代码时，就会进入一个执行上下文，执行上下文是一块内存空间，可以理解为一个对象，对象内包含了代码执行所需要的数据

变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为

每个上下文都又一个关联的变量对象 VO (variable object),该上下文中定义的所有变量和函数都存在于这个对象上

- EC分为三种

  1. **全局上下文**：默认执行环境，JS引擎最先进入的环境
  
  2. **函数上下文**：执行一个函数时，函数内部代码块的上下文

  3. eval上下文：eval函数内部代码的上下文

- 执行上下文内容：

  1. **this 指向**

  2. **VO 对象**

     - 对象内部包含

        1. `arguments`对象

        2. 参数

        3. 内部变量

        4. 函数声明

     - 类型

        1. GO(Global Object): 全局上下文中的VO

        2. AO(Active Object): 当前活跃的执行上下文的VO

        3. VO(Variable Object): 变量对象

### 执行上下文栈 ECS

- **执行上下文栈操作**

  1. JS引擎首先会进入默认环境（全局执行上下文），将全局执行上下文压入执行栈栈底，并开始执行

  2. 当在全局上下文中调用函数后，会进入函数执行上下文，并将函数执行上下文压入执行栈的顶部（入栈），若在函数执行上下文中再次遇到调用函数则将新调用的函数执行上下文压入执行栈执行。

  3. JS引擎会执行栈顶的执行上下文，因此每次新压入的函数会先被执行，当前执行上下文执行结束后会将该上下文弹出执行上下文栈，然后执行调用该函数时的执行上下文的后续代码。

- **执行上下文的建立**

  - 进入执行上下文（预编译）

     1. 确定所有形参的值（实参赋值给形参，未传实参的形参赋值为`undefined`），确定`arguments`的值

     2. 函数提升：将通过字面量声明的函数，将该变量指向函数对象。（若当前VO中有同名变量会覆盖）

     3. 变量提升：将在函数内通过`var`关键字定义的变量值设置为`undefined`。（若当前VO中有同名变量则忽略当前变量提升）

  - 执行阶段

### 作用域链

> 作用域链在函数创建时候就已经存在。

`VO`中包含一个属性（ ~~非`[[scope]]`~~ ），该属性指向创建该`VO`的函数本身（全局上下文不存在该属性）

函数创建（ ~~非执行~~ ）时候会有一个属性`[[scope]]`，该属性指向创建该函数时的执行上下文中的`AO`对象

当访问一个属性时：

  1. 在自身的`VO`中查找该属性，若有则返回

  2. 通过`VO`中指向创建`VO`的函数的属性找到 **对应函数**，通过函数中的`[[scope]]`属性找到创建函数时的`VO`对象。并在该`VO`对象内查找该属性，若有则返回。

  3. 依次往上查找直到全局作用域中的`GO`

:::tip Tip
  `[[scope]]`是**静态的**，指向函数创建时的AO，不会改变，调用多次函数，对应的始终是同一个`[[scope]]`，递归函数使用的是同一个`[[scope]]`，但是每次调用都会产生一个新的执行上下文。
:::


## 闭包

闭包：引用了另一个函数作用域中变量的函数

在一个函数内部定义的函数会把其外部的函数的AO对象添加到自己的作用域链中

作用域的前端为当前函数的AO对象，往后依次是外部函数的VO对象

闭包内部的函数如果没使用箭头函数，则this会指向**运行时**绑定到的执行上下文

## 事件循环

Event loop

事件循环是指，函数在执行栈、宿主线程、事件队列中的循环移动

- 浏览器的线程

  1. JS执行引擎：执行JS代码
  2. GUI线程：负责渲染页面
  3. HTTP网络线程：负责网络通信
  4. 事件监听线程：负责监听事件
  5. 计时器线程：负责计时器

### 事件队列

一块内存空间，用于存放执行时机到达的异步函数，当JS引擎 **空闲** 时（即执行栈没有可执行的上下文），它会从事件队列中拿出第一个事件执行。

- 队列：

  队列分为**宏队列**和**微队列**，执行栈清空时，JS引擎会先将微队列的任务执行完毕，然后再执行宏队列的任务。

  - 宏队列（macroTask）: 计时器结束的回调、事件监听的回调、http的回调等绝大部分异步函数

  - 微队列（microTask）：`Promise`的回调、`MutationObserver`的回调等进入微队列

:::tip tip

`settimeout`设置的时长为该计时器回调函数加入到队列最小的延迟时间，如果队列中无微任务，且栈为空，则该延时结束后会立即执行该函数，如果有其他优先级高的任务，则会等待其他任务处理完毕后再进行执行。

:::
