# 函数

## this指向

- 全局作用域中 `this`指向全局对象(如window)
  
- 函数作用域中，取决于 **函数如何被调用**

  1. 函数直接调用，`this`指向全局对象(如window)

  2. 通过对象调用 `obj.func()` ，`this` 指向该对象，（将对象方法保存到全局变量调用则指向全局对象 `var a = obj.func; a()`）

- call、apply、bind

  `Function`的原型上提供了三个修改this指向的方法

  - call：第一个参数this指向, 后续参数依次传入 `func.call(this, ...args)`
  
  - apply：第一个参数this指向，后续参数放在数组内传入 `func.apply(this, [...args])`

  - bind: 绑定this指向，返回一个函数 `func.bind(this, ...args)` 后续参数也可以当做先固定的参数

## 原型与原型链

### 原型

构造函数带有一个`prototype`属性（函数原型）函数原型可以看作是一个对象，里面包含了正常对象可以包含的属性和方法。

- `constructor`：构造函数原型内的prototype属性指向该构造函数本身

  ```js
    function Foo() { 
      //...
    }
    Foo.prototype.constructor === Foo // ture
  ```

### 隐式原型

- `__protp__`: 对象有一个私有属性 `__proto__`,该属性指向它构造函数的原型

  ```js
    const foo = new Foo()
    foo.__proto__ === Foo.prototype // true
  ```
- 构造函数的`__proto__`指向`Function.prototype` (绝大多数函数都是通过`new Function()` 创建的，即是`Function`的实例对象)

### 原型链

- 基于原型链的继承

当访问一个对象的属性时：

1. 查看该对象上是否存在目标属性，若存在则返回该属性
2. 查看该对象的隐式原型上是否存在目标属性，若存在则返回该属性
3. 继续往上层隐式原型中查找，直到搜索到该属性或到达原型链的顶端（`Object的原型的隐式原型为null`）

![原型链](/原型链.png)

[习题-原型链模拟继承](/面试/JS.md#原型链继承)

## 执行上下文

### 执行上下文 EC

  > 当控制器运行到一段可执行的代码时，就会进入一个执行上下文，执行上下文是一块内存空间，可以理解为一个对象，对象内包含了代码执行所需要的数据

- EC分为三种

  1. 全局上下文：默认执行环境，JS引擎最先进入的环境
  
  2. 函数上下文：执行一个函数时，函数内部代码块的上下文

  3. eval上下文：eval函数内部代码的上下文

- 执行上下文内容：

  1. **this 指向**

  2. **VO 对象**

     - 对象内部包含

        1. `arguments`对象

        2. 参数

        3. 内部变量

        4. 函数声明

     - 类型

        1. GO(Global Object): 全局上下文中的VO

        2. AO(Active Object): 当前活跃的执行上下文的VO

        3. VO(Variable Object): 变量对象

### 执行上下文栈 ECS

- **执行上下文栈操作**

  1. JS引擎首先会进入默认环境（全局执行上下文），将全局执行上下文压入执行栈栈底，并开始执行

  2. 当在全局上下文中调用函数后，会进入函数执行上下文，并将函数执行上下文压入执行栈的顶部（入栈），若在函数执行上下文中再次遇到调用函数则将新调用的函数执行上下文压入执行栈执行。

  3. JS引擎会执行栈顶的执行上下文，因此每次新压入的函数会先被执行，当前执行上下文执行结束后会将该上下文弹出执行上下文栈，然后执行调用该函数时的执行上下文的后续代码。

- **执行上下文的建立**

  - 进入执行上下文（预编译）

     1. 确定所有形参的值（实参赋值给形参，未传实参的形参赋值为`undefined`），确定`arguments`的值

     2. 函数提升：将通过字面量声明的函数，将该变量指向函数对象。（若当前VO中有同名变量会覆盖）

     3. 变量提升：将在函数内通过`var`关键字定义的变量值设置为`undefined`。（若当前VO中有同名变量则忽略当前变量提升）

  - 执行阶段

### 作用域链

> 作用域链在函数创建时候就已经存在。

`VO`中包含一个属性（ ~~非`[[scope]]`~~ ），该属性指向创建该`VO`的函数本身（全局上下文不存在该属性）

函数创建（ ~~非执行~~ ）时候会有一个属性`[[scope]]`，该属性指向创建该函数时的执行上下文中的`AO`对象

当访问一个属性时：

  1. 在自身的`VO`中查找该属性，若有则返回

  2. 通过`VO`中指向创建`VO`的函数的属性找到 **对应函数**，通过函数中的`[[scope]]`属性找到创建函数时的`VO`对象。并在该`VO`对象内查找该属性，若有则返回。

  3. 依次往上查找直到全局作用域中的`GO`

:::tip Tip
  `[[scope]]`是**静态的**，指向函数创建时的AO，不会改变，调用多次函数，对应的始终是同一个`[[scope]]`，递归函数使用的是同一个`[[scope]]`，但是每次调用都会产生一个新的执行上下文。
:::

## 事件循环

Event loop

事件循环是指，函数在执行栈、宿主线程、事件队列中的循环移动

- 浏览器的线程

  1. JS执行引擎：执行JS代码
  2. GUI线程：负责渲染页面
  3. HTTP网络线程：负责网络通信
  4. 事件监听线程：负责监听事件
  5. 计时器线程：负责计时器

### 事件队列

一块内存空间，用于存放执行时机到达的异步函数，当JS引擎 **空闲** 时（即执行栈没有可执行的上下文），它会从事件队列中拿出第一个事件执行。

- 队列：

  队列分为宏队列和微队列，执行栈清空时，JS引擎会先将微队列的任务执行完毕，然后再执行宏队列的任务。

  - 宏队列（macroTask）: 计时器结束的回调、事件监听的回调、http的回调等绝大部分异步函数

  - 微队列（microTask）：`Promise`的回调、`MutationObserver`的回调等进入微队列

> settimeout设置的时长为该计时器回调函数加入到队列最小的延迟时间，如果队列中无微任务，且栈为空，则该延时结束后会立即执行该函数，如果有其他优先级高的任务，则会等待其他任务处理完毕后再进行执行。

