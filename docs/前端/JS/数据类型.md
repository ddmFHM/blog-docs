# 数据类型

JS 常见的数据类型分为7种

## 常见数据类型

- **原始类型**

  1. `string`
  2. `number`
  3. `boolean`
  4. `undefined`
  5. `null`
  6. `Symbol    

- **引用类型**

  1. **`Object`**

      派生类型

      - `Array`
      - `Object`
      - `Date`
      - `Map`
      - `WeakMap`
      - `Set`
      - `WeakSet`
      - ...

## 类型检测

### **typeof 操作符**

`typeof` 操作符应用于检查数据类型，无法检测从 ~~`Object`~~ 派生出来的结构类型

`typeof` 可以检测出 `string`、`number`、`boolean`、`undefined`、`function`、`Symbol`类型。

`typeof` 对于`null`、`Array`、`Object`、`Date` 都输出为 `Object`

### **instanceof 运算符**

对于检查Objct适合使用`instanceof`运算符（也会有特殊情况）

`instanceof`运算符用于检查`constructor.prototype`是否在object的原型链上

```js
  object instanceof constructor
```

:::tip Tip
如果修改了构造函数的原型`prototype`，或者修改了实例对象的隐式原型(`__proto__`)都会使得原有的判断出现问题。
:::

### **Object.prototype.toString**

使用`Object`原型上的`toString`方法回返回表示该对象的字符串

```js
  const num = 1
  Object.prototype.toString.call(num)     // [object Number]

  const STRING = "String"
  Object.prototype.toString.call(STRING)  // [object String]

  const obj = {}
  Object.prototype.toString.call(obj)     // [object Object]

  const reg = /\reg/
  Object.prototype.toString.call(reg)     // [object RegExp]

  const reg = /\reg/
  Object.prototype.toString.call(reg)     // [object RegExp]

  const bool = true
  Object.prototype.toString.call(bool)    // [object Boolean]

  const func = function() {}
  Object.prototype.toString.call(func)    // [object Function]
```

## 变量

1. var

   - 允许重复声明

   - 会有变量提升

   - 会挂在到window对象下

2. let

   - 不允许重复声明

   - 不会污染全局变量

   - 不允许声明前使用

3. const

   - 与let基本相同

   - 声明时就要赋值

   - 对于原始类型不可重新赋值，引用类型可以保证引用地址不变，但是不可保证其内属性不发生变化

    ```js
      const num = 1
      num = 2 // Uncaught TypeError: Assignment to constant variable.

      const obj = {
        x: 1,
        y: 2
      }
      obj = {} // Uncaught TypeError: Assignment to constant variable.
      obj.x = 2
      console.log(obj) // {x: 2, y: 2}
    ```

### 暂时性死区

底层实现上 let 也有变量提升，但是提升后会将其放入暂时性死区，如果访问位于暂时性死区的变量则会报错，当代码运行到该变量声明时候，会将其移出暂时性死区,形参中也有暂时性死区
