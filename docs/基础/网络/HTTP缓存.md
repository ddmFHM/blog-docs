# HTTP 缓存

HTTP 缓存是指当客户端向服务端请求资源时，会先抵达**浏览器缓存**，如果浏览器缓存有该请求资源的副本，就可以直接从浏览器缓存中提取，不需要再次请求服务器。

常见的HTTP缓存只能缓存`GET`请求，HTTP缓存都是从**第二次**请求开始的

- 第一次请求时
  
  - 服务器返回资源

  - 在响应头内设定缓存的参数（字段）

    - 强缓存：`Cache-Control`、`Expires`

    - 协商缓存：`ETag`、`Last-Modified`

- 第二次请求时

  - 浏览器判断参数

  - 是否命中**强缓存**
    
    - 命中强缓存（强缓存时间没到期）直接返回`200`状态码。

    - 未命中强缓存，把 `ETag`、`Last-Modified` 的值添加到请求头内发送给服务器
  
  - 是否命中**协商缓存**

    - 命中协商缓存，返回`304`状态码

    - 返回资源

## 强缓存

缓存数据未失效的情况下，会直接使用浏览器的缓存数据，**不会**向服务器发送请求

未失效情况：

  1. `Cache-Control`的`max-age`未过期

  2. `Expires`的缓存时间未过期

强缓存生效时，浏览器直接返回 HTTP状态码`200`，该情况页面加载最快，性能最好。

:::warning 缺点

强缓存有效期间，如果服务器修改资源，则无法请求到（不会发出请求）

:::

请求头字段：

- **`Pragma`(HTTP1.0，优先级大于`Cache-Control`)**

  - `no-cache`: 不直接使用缓存，兼容HTTP/1.0客户端

- **`Cache-Control`(HTTP/1.1)**

  1. `no-cache` : 使用缓存前会**先请求**服务器判断缓存是否最新（跳过强缓存直接走协商缓存）

  2. `no-store` : 不适用缓存，每次都请求下载新资源

  3. `max-age` : 缓存时长（单位秒）

  4. `public / private` : 是否只能被单个用户使用
    
    - `private` : 默认 只有客户端能缓存，代理服务不可)
    - `public` : 客户端代理服务器都可缓存

  5. `must-revalidate` : 每次访问需要验证缓存

- `Expires`(HTTP/1.0+)

  > 基本已经淘汰

  GMT时间：使用 HTTP1.0 和 1.1，在缓存失效前获取不到修改后的资源，客户端和服务端时间不一致会出现问题

## 协商缓存

**第一次**请求时，响应头内无`Cache-Control`和`Expires`字段，或**后续请求**中，`Cache-Control`、`Expires`过期（未命中强缓存）

则浏览器下次请求会与服务器进行协商，与服务器对比判断资源是否进行了修改

- 若未发生修改，则返回HTTP状态码`304`，告知浏览器可以使用缓存中的数据（减少服务器数据传输压力）

- 如已发送修改，则返回HTTP状态码`200`，并返回更新后的资源，以及在响应头内携带缓存信息返回

| <div style="width: 90pt">响应头字段</div> | <div style="width: 110pt">请求头字段</div> | 描述 |
|:----:|:--:|:--|
| `ETag` | `If-Not-Match` | (HTTP1.1) 参数为校验值，优先级高，默认使用hash算法，可以识别一秒内的修改，计算`ETag`有性能消耗 |
| `Last-Modified` | `If-Modified-Since` | (HTTP1.0)参数为GMT时间，精度为秒，优先级低，只要资源修改了，无论内容有无变化都会返回资源给客户端，以时间为标识，无法获取一秒内的修改，某些服务器不能准确获取最后的修改时间。 |

- <font size=4 color="#6B95BF">协商缓存流程</font>

  - 当浏览器第一次向服务器发送请求时，会在**响应头**中返回协商缓存的`header`属性，`Etag`和`Last-Modified`,其中`ETag`为一个hash值，`Last-Modified`是GMT格式的最后修改时间。

  - 当浏览器第二次向服务器发送请求时，会在**请求头**上带上与`ETag`对应的`If-None-Match`,其值就是响应头中返回的`Etag`的hash值，`Last-Modified`对应的`If-Modified-Since`就是响应头返回的`Last-Modified`值，服务器收到这两个参数后会进行比较，如果返回的304则说明资源未被修改，浏览器可以直接在缓存中读取数据，如果资源已经被修改了，则再次请求服务器接收新的资源（新资源就是新的hash和GMT时间）

- `Etag` / `If-Not-Match`是在HTTP1.1出现的，解决以下问题

  - Last-Modifed精确到秒级，如果1秒被修改多次，则不能准确标注这多次的变化

  - 如果某些文件被修改了，但是内容没变化，而`Last-Modified`却改变了，导致文件无法使用缓存

  - 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致的情况

## other

- 私有缓存

  - 私有缓存只能用于单独的用户不能用于代理服务器：Cache-Control: Private

- 共享缓存

  - 共享缓存可以被多个用户使用，代理服务器可以使用：Cache-Control: public

- 禁用缓存

  - 在 meta标签内 设置

    - `<meta http-equiv="cache-control" content="no-cache">`
    - `<meta http-equiv="expires" content="0">`

- 不适用缓存的情况

  - 直接 Ctrl + F5 刷新，会直接向服务器请求数据
  
  - F5刷新或者点击浏览器刷新按钮，默认会加上Cache-Control: max-age=0，即走协商缓存

  - 不保存历史记录
