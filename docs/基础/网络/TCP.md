# TCP

TCP 协议

## TCP 报文

- sequence number：序号，32位
- acknowledgement number：确认号，占32位，只有ACK标志位为1时，确认序号字段才有效 Ack = seq + 1
- flag：标志位6个

  1. URG：紧急指针
  2. ACK：确认序号有效
  3. PSH：接受方应尽快将这个报文交给应用层
  4. RST：重置连接
  5. SYN：发起一个新连接
  6. FIN: 释放一个连接

## TCP 三次握手

> 三次握手即 TCP连接的建立，一方主动打开，另一方被动打开

![avatar](/三次握手.jpeg)

- 握手之前 客户端结束CLOSED阶段，被动打开的服务端也结束CLOSED状态，并且服务端进入LISTEN阶段，然后开始三次握手

---

1. **<font size=4 color="#6B95BF">客户端向服务端发送一段TCP报文</font>**

    - 标记位为SYN，表示请求建立新连接
    
    - 序号Seq=X (X 一般为1)

    - 随后客户端进入 SYN-SEND 阶段

2. **<font size=4 color="#6B95BF">服务端接收到了来自客户端的 TCP报文后，结束LISTEN阶段，并返回一段TCP报文</font>**

    - 标志位为SYN和ACK，表示确认客户端的包围Seq序号有效，服务器能正常接收客户端数据，并同意创建新的连接

    - 序号 Seq=y

    - 确认号为ACK=x+1，表示收到客户端的序号Seq并且将其值加1作为确认号Ack的值，随后服务端进入 SYN-RCVD阶段

3. **<font size=4 color="#6B95BF">客户端接收到来自服务器的确认收到数据的TCP报文后，确认了数据传输正常，结束SYN-SEND阶段，并返回一段TCP报文</font>**

    - 标志位为ACK，表示确认收到服务器端同意连接的信号

    - Seq=x+1，表示收到服务器的Ack确认号，并将其值加1作为自己的Seq序号值

    - 确认号为Ack=y+1，表示收到服务器的序号Seq，并将其值加1作为自己的确认号Ack的值

    - 随后客户端进入ESTABLISHED阶段

4. **<font size=4 color="#6B95BF">服务端接收到客户端发送的确认收到服务器数据的TCP报文后，确定了传输是正常的，结束SYN-RCVD阶段，进入ESTABLISHED</font>**


![avatar](/三次握手动图.gif)

---
- 客户端与服务端传输的TCP报文中，双方的Ack和Seq都是在对方的Ack和Seq值得基础上进行计算的，保证了TCP报文传输的连贯性，一旦出现一方报文丢失，便无法继续握手，确保三次握手顺利完成

- 为什么要进行第三次握手

  - 防止服务端开启一些无用的连接，增加服务器开销

    - 因为传输时有延迟的，如果当客户端发起第一次请求后，服务端就直接建立连接，然后返回TCP报文，如果这个数据包因为网络原因丢失了，之后客户端就 一直无法接收到服务端返回的数据包。如果客户端设置了超时重传，一定时间后，就会关闭这个连接创建的请求，服务端并不知到客户端未接收到数据，所以服务端也不会收到客户端创建或者关闭连接的请求，这样整个端口就会一直打开，如果客户端超时重新发起请求后，服务端会重新开启一个新的连接，原本的端口就一直开着，会造成不必要的开销

  - 防止服务端收到一些已经失效的报文

    - 某些已经失效的客户端请求信息某种原因又发送到了服务端，服务端会认为是客户端发送的请求，造成异常的处理

## TCP 四次挥手

![avatar](/四次挥手.jpeg)

四次挥手即TCP连接的释放，一方主动释放，另一方被动释放，四次挥手结束之前三次握手的ESTABLISHED状态

---

1. **<font size=4 color="#6B95BF">客户端要释放连接，需要向服务器发送一段TCP报文</font>**

    - 标记位为 FIN 表示 请求释放连接
    
    - 序号为Seq=U

    - 随后客户端进入 FIN-WAIT-1 阶段（半关闭阶段），并且停止在客户端到服务端方向的数据发送，但是仍然能接收到服务端传送过来的数据（不发送的是正常传输的数据，ACK确认报文等仍然能够发送）

2. **<font size=4 color="#6B95BF">服务端接收到客户端发出的TCP报文后，确认了客户端想要释放连接，随后服务端结束ESTABLISHED阶段进入 CLOSE-WAIT阶段（半关闭阶段）并且返回一个TCP报文</font>**

    - 标记位为 Ack,表示 接收到客户端发送的释放连接的请求

    - 序号为Seq=V

    - 确认号为Ack=U+1 表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值

    - 随后服务端开始准备释放 服务端到客户端方向 的连接

    - 客户端收到服务端发出的这个TCP报文后，确认了服务器收到客户端发送的释放连接请求，随后客户端接收FIN-WAIT-1阶段，进入FIN-WAIT-2阶段

    （前两次挥手，让服务端知道了客户端要释放连接，客户端知道了服务端收到了客户端想要释放连接的请求，于是可以确认关闭客户端到服务端方向的连接了）

3. **<font size=4 color="#6B95BF">服务端发出ACK确认报文后，经过CLOSED-WAIT阶段，做好了释放服务端到客户端方向上连接的准备，再次向客户端发出一段TCP报文</font>**

    - 标记位位FIN，ACK 表示 已经准备豪释放连接了，（这里的ACK不是确认收到服务器端报文的确认报文）

    - 序号Seq=W

    - 确认号Ack=U+1，表示是在收到客户端报文的基础上将其序号Seq值加1作为本段报文确认号ACK的值

    - 随后服务端结束CLOSE-WAIT阶段，进入LAST-ACK阶段，并且停止服务端到客户端方向上发送数据，但是仍然能接收到客户端发送的数据

4. **<font size=4 color="#6B95BF">客户端收到从服务器发出的TCP报文，确认了服务器已经做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并且向服务端发送一段报文</font>**

    - 标记位位ACK 表示接收到服务器准备释放连接的信号

    - 序号位Seq=U+1表示是在接收到服务端报文的基础上，将其确认号Ack值加1作为本段报文序号的值

    - 确认号Ack=W+1，表示是在收到了服务器端报文的基础上，将其序号Seq的值加1 作为本段报文确认号的值

    - 随后客户端在TIME-WAIT阶段等待2MSL

    - 服务单收到客户端发出的TCP报文后，结束LAST-ACK阶段，进入CLOSED阶段，正式关闭服务端到客户端的连接

    - 客户端等待2MSL后，结束TIME-WAIT阶段，进入CLOSED阶段，完成四次挥手

    （后两次挥手，既让客户端知道服务器准备好了释放连接，也让服务端知道了客户端知道服务端准备好释放连接，于是确认服务端到客户端方向的连接，完成四次挥手）

![avatar](/四次挥手动图.gif)

- 为什么握手三次挥手四次

  - 因为第二次握手的时候服务端发送给客户端的报文有SYN 和 ACK，SYN是请求连接，表示服务端同意建立连接，ACK是确认报文，表示告诉客户端，服务器收到了请求报文，两个信息同一次传输

  - 四次挥手是 FIN 和 ACK 分别由 第二次和第三次挥手传输的

    - 连接握手时，从CLOSED阶段进入三次握手阶段不需要准备

    - 释放挥手时，突然收到客户端的释放请求，并不能马上释放连接，要将必要的数据进行处理，所以要先返回ACK确认报文，在CLOSE-WAIT阶段准备好释放后，再返回FIN 释放连接的报文。

- 为什么要等待2MSL

  - MSL即一个TCP报文在传输过程中最大的生命周期，2MSL即服务端发送FIN报文和客户端发送ACK确认报文能保持的最大时长

  - 如果服务端未接收到客户端的ACK确认报文，就会重新在发送一次FIN释放连接的报文

  - 因此，如果客户端在2MSL内再次收到服务端发送的FIN报文，表示服务端没有接收到客户端发送的ACK报文，客户端会重新发送一次ACK确认报文，然后重置2MSL计时

  - 如果2MSL内未收到FIN报文，则表示客户端已经收到ACK确认报文，所以客户端可以进入CLOSED状态完成四次挥手
    

## TCP 和 UDP 区别

> TCP 和 UDP 都是 OSI模型中运输层的协议 TCP提供可靠通信传输，UDP常用于广播，或通信细节控制交给应用层的通信传输

- TCP

  - TCP面向连接，发送数据前必须要在两端建立间接，即三次握手

  - TCP仅支持单播传输，点对点数据传输，不支持多播和广播模式

  - TCP是面向字节流的 以字节流的方式传输

  -  优点

      - 可靠稳定，TCP有三次握手建立连接

      - 数据传输时，有确认，窗口，重传，拥塞控制机制

      - 数据传输完毕后，会断开连接节约资源

  - 缺点

     - 慢，效率低，占用资源高，容易被攻击。

- UDP

  - UDP是无连接的

  - UDP支持一对一，一对多，多对一，多对多通信

  - UDP是面向报文的，UDP不会对报文进行拆分和拼接操作
    
    - 在发送端，应用层讲数据传递给UDP，DUO只会给数据增加一个UDP头标识一下是UDP协议，然后直接传输给网络层。 
    
    - 在接收端，网络层将数据传递给运输层，UDP只去除IP报文头就传递给应用层。

  - UDP没有握手，确认，窗口，重传，拥塞控制等机制，是无状态的传输协议，传递数据快

  - 优点

    - 快，比TCP稍微安全

  - 缺点

    - 不可靠，不稳定

    - 如果网络之类不好，在数据传输时容易丢包

- 应用场景

  - TCP适合 需要可靠传输的地方，如HTTP,HTTPS,FTP等传输文件的协议，用在浏览器，文件传输等场景

  - UDP适合 需要传输速率快的，网络通信质量要求不高的地方，比如，语音，视频等

- 小结

  - TCP系统资源要求多，UDP要求少

  - UDP结构相对简单

  - 流模式与数据报模式

  - TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证
  
  - TCP 向上层提供面向连接的可靠服务，UDP向上层提供无连接的不可靠服务